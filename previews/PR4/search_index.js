var documenterSearchIndex = {"docs":
[{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the AlgorithmsInterface.jl documentation. Usually you find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"interface/#Main-Interface-types","page":"Interface","title":"Main Interface types","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [AlgorithmsInterface]\nPages = [\"interface/interface.jl\"]\nOrder = [:type, :function]\nPrivate = true","category":"page"},{"location":"interface/#AlgorithmsInterface.initialize_state!-Tuple{State, Problem, Algorithm}","page":"Interface","title":"AlgorithmsInterface.initialize_state!","text":"s = initialize_state(p::Problem, a::Algorithm; kwargs...)\ninitialize_state!(p::Problem, a::Algorithm, s::State; kwargs...)\n\nInitialize a State s base on a Problem p and an Algorithm. The kwargs... should allow to initialize for example the initial point. This can be done in-place of s, then only values that did change have to be provided.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.initialize_state-Tuple{Problem, Algorithm}","page":"Interface","title":"AlgorithmsInterface.initialize_state","text":"s = initialize_state(p::Problem, a::Algorithm; kwargs...)\ninitialize_state!(p::Problem, a::Algorithm, s::State; kwargs...)\n\nInitialize a State s base on a Problem p and an Algorithm. The kwargs... should allow to initialize for example the initial point. This can be done in-place of s, then only values that did change have to be provided.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.is_finished-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.is_finished","text":"is_finished(p::Problem, a::Algorithm, s::State)\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.solve!-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.solve!","text":"solve!(p::Problem, a::Algorithm, s::State; kwargs...)\n\nSolve the Problem p using the Algorithm a working on the State.\n\nAll keyword arguments are passed to the initialize_state! function.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.solve-Tuple{Problem, Algorithm}","page":"Interface","title":"AlgorithmsInterface.solve","text":"solve(p::Problem, a::Algorithm; kwargs...)\n\nSolve the Solve the Problem p using the Algorithm a. The keyword arguments kwargs... have to provide enough details such that the corresponding state initialisation initialize_state(p,a) returns a state.\n\nBy default this method continues to call solve!.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.step!-Tuple{Problem, Algorithm, State}","page":"Interface","title":"AlgorithmsInterface.step!","text":"step!(p::Problem, a::Algorithm, s::State)\n\nPerform the current step of an Algorithm a solving Problem p starting from State s.\n\n\n\n\n\n","category":"method"},{"location":"interface/#Algorithm","page":"Interface","title":"Algorithm","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [AlgorithmsInterface]\nPages = [\"interface/algorithm.jl\"]\nOrder = [:type, :function]\nPrivate = true","category":"page"},{"location":"interface/#AlgorithmsInterface.Algorithm","page":"Interface","title":"AlgorithmsInterface.Algorithm","text":"Algorithm\n\nAn abstract type to represent an algorithm.\n\nA concrete algorithm contains all static parameters that characterise the algorithms. Together with a Problem an Algorithm subtype should be able to initialize or reset a State.\n\nExample\n\nFor a gradient descent algorithm the algorithm would specify which step size selection to use.\n\n\n\n\n\n","category":"type"},{"location":"interface/#Problem","page":"Interface","title":"Problem","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [AlgorithmsInterface]\nPages = [\"interface/problem.jl\"]\nOrder = [:type, :function]\nPrivate = true","category":"page"},{"location":"interface/#AlgorithmsInterface.Problem","page":"Interface","title":"AlgorithmsInterface.Problem","text":"Problem\n\nAn abstract type to represent a problem to be solved with all its static properties, that do not change during an algorithm run.\n\nExample\n\nFor a gradient descent algorithm the problem consists of\n\na cost function f C  ℝ\na gradient function operatornamegradf\n\nThe problem then could that these are given in four different forms\n\na function c = cost(x) and a gradient d = gradient(x)\na function c = cost(x) and an in-place gradient gradient!(d,x)\na combined cost-grad function (c,d) = costgrad(x)\na combined cost-grad function (c, d) = costgrad!(d, x) that computes the gradient in-place.\n\n\n\n\n\n","category":"type"},{"location":"interface/#State","page":"Interface","title":"State","text":"","category":"section"},{"location":"interface/","page":"Interface","title":"Interface","text":"Modules = [AlgorithmsInterface]\nPages = [\"interface/state.jl\"]\nOrder = [:type, :function]\nPrivate = true","category":"page"},{"location":"interface/#AlgorithmsInterface.State","page":"Interface","title":"AlgorithmsInterface.State","text":"State\n\nAn abstract type to represent the state an iterative algorithm is in.\n\nThe state consists of any information that describes the current step the algorithm is in and keeps all information needed from one step to the next.\n\nUsually this should include\n\niteration – the current iteration step k that is is currently performed or was last performed\nstopping_criterion – a StoppingCriterion that indicates whether the algorithm will stop after this iteration or has stopped.\niterate the current iterate x^(k)`.\n\nThese variable names given in this list are the defaults for which the accessors are implemented, such that if your concrete MyState <: State follows this convention, you do not have to reimplement their accessors.\n\nMethods\n\nThe following methods should be implemented for a state\n\nget_iteration(s) to return the current iteration number\n`increment!(s)\nget_stopping_criterion return the StoppingCriterion\nget_iterate return the current iterate x^(k).\n\n\n\n\n\n","category":"type"},{"location":"interface/#AlgorithmsInterface.get_iterate-Tuple{State}","page":"Interface","title":"AlgorithmsInterface.get_iterate","text":"get_iterate(s::State)\n\nReturn the current iterate x^(k) of a State s\n\nThe default assumes that the current iteration is stored in s.iterate.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.get_iteration-Tuple{State}","page":"Interface","title":"AlgorithmsInterface.get_iteration","text":"get_iteration(s::State)\n\nReturn the current iteration a State s either is currently performing or was last performed\n\nThe default assumes that the current iteration is stored in s.iteration.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.get_stopping_criterion-Tuple{State}","page":"Interface","title":"AlgorithmsInterface.get_stopping_criterion","text":"get_stopping_criterion(s::State)\n\nReturn the StoppingCriterion of the State s.\n\nThe default assumes that the criterion is stored in s.stopping_criterion.\n\n\n\n\n\n","category":"method"},{"location":"interface/#AlgorithmsInterface.increment!-Tuple{State}","page":"Interface","title":"AlgorithmsInterface.increment!","text":"increment!(s::State)\n\nReturn the current iteration a State s either is currently performing or was last performed\n\nThe default assumes that the current iteration is stored in s.iteration.\n\n\n\n\n\n","category":"method"},{"location":"stopping_criterion/#Stopping-criterion","page":"Stopping criteria","title":"Stopping criterion","text":"","category":"section"},{"location":"stopping_criterion/","page":"Stopping criteria","title":"Stopping criteria","text":"Modules = [AlgorithmsInterface]\nPages = [\"stopping_criterion.jl\"]\nOrder = [:type, :function]\nPrivate = true","category":"page"},{"location":"stopping_criterion/#AlgorithmsInterface.StopAfter","page":"Stopping criteria","title":"AlgorithmsInterface.StopAfter","text":"StopAfter <: StoppingCriterion\n\nstore a threshold when to stop looking at the complete runtime. It uses time_ns() to measure the time and you provide a Period as a time limit, for example Minute(15).\n\nFields\n\nthreshold stores the Period after which to stop\nstart stores the starting time when the algorithm is started, that is a call with i=0.\ntime stores the elapsed time\nat_iteration indicates at which iteration (including i=0) the stopping criterion was fulfilled and is -1 while it is not fulfilled.\n\nConstructor\n\nStopAfter(t)\n\ninitialize the stopping criterion to a Period t to stop after.\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StopAfterIteration","page":"Stopping criteria","title":"AlgorithmsInterface.StopAfterIteration","text":"StopAfterIteration <: StoppingCriterion\n\nA functor for a stopping criterion to stop after a maximal number of iterations.\n\nFields\n\nmax_iterations  stores the maximal iteration number where to stop at\nat_iteration indicates at which iteration (including i=0) the stopping criterion was fulfilled and is -1 while it is not fulfilled.\n\nConstructor\n\nStopAfterIteration(maxIter)\n\ninitialize the functor to indicate to stop after maxIter iterations.\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.StoppingCriterion","page":"Stopping criteria","title":"AlgorithmsInterface.StoppingCriterion","text":"StoppingCriterion\n\nAn abstract type to represent a stopping criterion of an solver.\n\nAny concrete stopping criterion should be implemented as a functor, that takes the “usual tuple” (p, a, s) of a Problem p, an Algorithm and a State as input, where this criterion should usually be part of the State itself.\n\nMethods\n\nA concrete StoppingCriterion sc should provide the following functions besides the above-mentioned functor is it itself\n\nget_reason(sc) a human readable text of about one line of length providing a reason why this stopping criterion indicated to stop. An empty string if it did not indicate to stop\nget_summary(sc) a short summary of this stopping criterion, and whether it was reached, e.g. a short string like \"Max Iterations (15): reached\"\nindicates_convergence(sc) a boolean whether or not this stopping criterion would indicate that the algorithm has converged, if it indicates to stop.\nshow(io::IO, sc) to display its constructor and the get_summary\n\n\n\n\n\n","category":"type"},{"location":"stopping_criterion/#AlgorithmsInterface.get_reason-Tuple{StoppingCriterion}","page":"Stopping criteria","title":"AlgorithmsInterface.get_reason","text":"get_reason(sc::StoppingCriterion)\n\nProvide a reason in human readable text as to why a StoppingCriterion indicated to stop. If it does not indicate to stop, this should return an empty string.\n\nProviding the iteration at which this indicated to stop would be preferrable.\n\n\n\n\n\n","category":"method"},{"location":"stopping_criterion/#AlgorithmsInterface.get_summary-Tuple{StoppingCriterion}","page":"Stopping criteria","title":"AlgorithmsInterface.get_summary","text":"get_summary(sc::StoppingCriterion)\n\nProvide a summary of the status of a stopping criterion – its parameters and whether it currently indicates to stop. It should not be longer than one line\n\nExample\n\nFor the StopAfterIteration criterion, the summary looks like\n\nMax Iterations (15): not reached\n\n\n\n\n\n","category":"method"},{"location":"stopping_criterion/#AlgorithmsInterface.indicates_convergence-Tuple{StoppingCriterion}","page":"Stopping criteria","title":"AlgorithmsInterface.indicates_convergence","text":"indicates_convergence(sc::StoppingCriterion)\n\nReturn whether or not a StoppingCriterion indicates convergence of an algorithm if it would indicate to stop.\n\n\n\n\n\n","category":"method"},{"location":"#AlgorithmsInterface.jl","page":"Home","title":"AlgorithmsInterface.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the Documentation of LieGAlgorithmsInterface.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgorithmsInterface","category":"page"},{"location":"","page":"Home","title":"Home","text":"AlgorithmsInterface.AlgorithmsInterface","category":"page"},{"location":"#AlgorithmsInterface.AlgorithmsInterface","page":"Home","title":"AlgorithmsInterface.AlgorithmsInterface","text":"🧮 AlgorithmsInterface.jl: an interface for iterative algorithms in Julia\n\n📚 Documentation: juliamanifolds.github.io/AlgorithmsInterface.jl/\n📦 Repository: github.com/JuliaManifolds/AlgorithmsInterface.jl\n💬 Discussions: github.com/JuliaManifolds/AlgorithmsInterface.jl/discussions\n🎯 Issues: github.com/JuliaManifolds/AlgorithmsInterface.jl/issues\n\n\n\n\n\n","category":"module"}]
}
