var documenterSearchIndex = {"docs":
[{"location":"references/#Literature","page":"References","title":"Literature","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"This is all literature mentioned / referenced in the AlgorithmsInterface.jl documentation. Usually you find a small reference section at the end of every documentation page that contains the corresponding references as well.","category":"page"},{"location":"references/","page":"References","title":"References","text":"","category":"page"},{"location":"#IterativeAlgorithms.jl","page":"Home","title":"IterativeAlgorithms.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Algorithm\nProblem\nState\nstep!\nget_iteration","category":"page"},{"location":"#AlgorithmsInterface.Algorithm","page":"Home","title":"AlgorithmsInterface.Algorithm","text":"Algorithm\n\nAn abstract type to represent an algorithm.\n\nA concrete algorithm contains all static parameters that characterise the algorithms. Together with a Problem an Algorithm subtype should be able to initialize or reset a State.\n\nExample\n\nFor a gradient descent algorithm the algorithm would specify which step size selection to use.\n\n\n\n\n\n","category":"type"},{"location":"#AlgorithmsInterface.Problem","page":"Home","title":"AlgorithmsInterface.Problem","text":"Problem\n\nAn abstract type to represent a problem to be solved with all its static properties, that do not change during an algorithm run.\n\nExample\n\nFor a gradient descent algorithm the problem consists of\n\na cost function f C  ℝ\na gradient function operatornamegradf\n\nThe problem then could that these are given in four different forms\n\na function c = cost(x) and a gradient d = gradient(x)\na function c = cost(x) and an in-place gradient gradient!(d,x)\na combined cost-grad function (c,d) = costgrad(x)\na combined cost-grad function (c, d) = costgrad!(d, x) that computes the gradient in-place.\n\n\n\n\n\n","category":"type"},{"location":"#AlgorithmsInterface.State","page":"Home","title":"AlgorithmsInterface.State","text":"State\n\nAn abstract type to represent the state an iterative algorithm is in.\n\nThe state consists of any information that describes the current step the algorithm is in and keeps all information needed from one step to the next.\n\nUsually this should include\n\niteration – the current iteration step k that is is currently performed or was last performed\nstopping_criterion – a StoppingCriterion that indicates whether the algorithm will stop after this iteration or has stopped.\niterate the current iterate x^(k)`.\n\nThese variable names given in this list are the defaults for which the accessors are implemented, such that if your concrete MyState <: State follows this convention, you do not have to reimplement their accessors.\n\n\n\n\n\n","category":"type"},{"location":"#AlgorithmsInterface.step!","page":"Home","title":"AlgorithmsInterface.step!","text":"step!(p::Problem, a::Algorithm, s::State)\n\nPerform the current step of an Algorithm a solving Problem p starting from State s.\n\n\n\n\n\n","category":"function"},{"location":"#AlgorithmsInterface.get_iteration","page":"Home","title":"AlgorithmsInterface.get_iteration","text":"get_iteration(s::State)\n\nReturn the current iteration a state either is currently performing or was last performed\n\nThe default assumes that the current iteration is stored in s.iteration.\n\n\n\n\n\n","category":"function"}]
}
